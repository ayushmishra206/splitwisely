-- Migration: init
-- Generated by Supabase CLI

create extension if not exists "pgcrypto";

create or replace function public.handle_updated_at()
returns trigger
language plpgsql
as $$
begin
	new.updated_at = timezone('utc', now());
	return new;
end;
$$;

create table if not exists profiles (
	id uuid primary key references auth.users(id) on delete cascade,
	full_name text,
	avatar_url text,
	created_at timestamptz not null default timezone('utc', now())
);

create table if not exists groups (
	id uuid primary key default gen_random_uuid(),
	owner_id uuid not null references profiles(id) on delete cascade,
	name text not null,
	description text,
	currency text not null default 'USD',
	created_at timestamptz not null default timezone('utc', now()),
	updated_at timestamptz not null default timezone('utc', now())
);

create trigger set_groups_updated_at
before update on groups
for each row
execute procedure handle_updated_at();

create table if not exists group_members (
	group_id uuid not null references groups(id) on delete cascade,
	member_id uuid not null references profiles(id) on delete cascade,
	role text not null default 'member' check (role in ('owner', 'member')),
	joined_at timestamptz not null default timezone('utc', now()),
	primary key (group_id, member_id)
);

create table if not exists expenses (
	id uuid primary key default gen_random_uuid(),
	group_id uuid not null references groups(id) on delete cascade,
	payer_id uuid references profiles(id) on delete set null,
	description text not null,
	amount numeric(12, 2) not null check (amount >= 0),
	expense_date date not null default current_date,
	notes text,
	created_at timestamptz not null default timezone('utc', now()),
	updated_at timestamptz not null default timezone('utc', now())
);

create trigger set_expenses_updated_at
before update on expenses
for each row
execute procedure handle_updated_at();

create table if not exists expense_splits (
	id uuid primary key default gen_random_uuid(),
	expense_id uuid not null references expenses(id) on delete cascade,
	member_id uuid not null references profiles(id) on delete cascade,
	share numeric(12, 2) not null check (share >= 0)
);

create table if not exists settlements (
	id uuid primary key default gen_random_uuid(),
	group_id uuid not null references groups(id) on delete cascade,
	from_member uuid not null references profiles(id) on delete cascade,
	to_member uuid not null references profiles(id) on delete cascade,
	amount numeric(12, 2) not null check (amount >= 0),
	settlement_date date not null default current_date,
	notes text,
	created_at timestamptz not null default timezone('utc', now())
);

alter table profiles enable row level security;
alter table groups enable row level security;
alter table group_members enable row level security;
alter table expenses enable row level security;
alter table expense_splits enable row level security;
alter table settlements enable row level security;

drop policy if exists "Profiles are self-insertable" on profiles;
create policy "Profiles are self-insertable"
	on profiles for insert
	with check (auth.uid() = id);

drop policy if exists "Profiles are self-readable" on profiles;
create policy "Profiles are self-readable"
	on profiles for select using (auth.uid() = id);

create or replace function is_group_member(target_group uuid)
returns boolean
language plpgsql
security definer
set search_path = public
as $$
declare
	membership_count integer;
begin
	select count(*) into membership_count
	from group_members
	where group_id = target_group and member_id = auth.uid();

	return membership_count > 0;
end;
$$;

create or replace function is_group_admin(target_group uuid)
returns boolean
language plpgsql
security definer
set search_path = public
as $$
begin
	return exists (
		select 1
		from group_members
		where group_id = target_group
		  and member_id = auth.uid()
		  and role = 'owner'
	);
end;
$$;

drop policy if exists "Profiles readable to authenticated" on profiles;
create policy "Profiles readable to authenticated"
	on profiles
	for select
	using (auth.uid() is not null);

drop policy if exists "Profiles are self-updatable" on profiles;
create policy "Profiles are self-updatable"
	on profiles for update using (auth.uid() = id);

drop policy if exists "Group owners insert groups" on groups;
create policy "Group owners insert groups"
	on groups
	for insert
	with check (owner_id = auth.uid());

drop policy if exists "Group owners update groups" on groups;
create policy "Group owners update groups"
	on groups
	for update
	using (owner_id = auth.uid());

drop policy if exists "Group owners delete groups" on groups;
create policy "Group owners delete groups"
	on groups
	for delete
	using (owner_id = auth.uid());

drop policy if exists "Members read groups" on groups;
create policy "Members read groups"
	on groups
	for select
	using (
		owner_id = auth.uid()
		or is_group_member(id)
	);

grant select on groups to authenticated;

drop policy if exists "Members read group membership" on group_members;
create policy "Members read group membership"
	on group_members
	for select
	using (is_group_member(group_id));

drop policy if exists "Owners manage membership" on group_members;
create policy "Owners manage membership"
	on group_members
	for all
	using (is_group_admin(group_id))
	with check (is_group_admin(group_id));

drop policy if exists "Members manage their membership" on group_members;
create policy "Members manage their membership"
	on group_members
	for delete
	using (member_id = auth.uid());

drop policy if exists "Members read expenses" on expenses;
create policy "Members read expenses"
	on expenses
	for select using (is_group_member(group_id));

drop policy if exists "Members write expenses" on expenses;
create policy "Members write expenses"
	on expenses
	for all using (is_group_member(group_id));

drop policy if exists "Members manage splits" on expense_splits;
create policy "Members manage splits"
	on expense_splits
	for all using (
		expense_id in (
			select id from expenses where is_group_member(group_id)
		)
	);

drop policy if exists "Members manage settlements" on settlements;
create policy "Members manage settlements"
	on settlements
	for all using (is_group_member(group_id));

grant usage on schema public to authenticated;
grant select, insert, update, delete on all tables in schema public to authenticated;
